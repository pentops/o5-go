// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: o5/application/v1/application.proto

package application_pb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Application with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Application) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Application with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ApplicationMultiError, or
// nil if none found.
func (m *Application) ValidateAll() error {
	return m.validate(true)
}

func (m *Application) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_Application_Name_Pattern.MatchString(m.GetName()) {
		err := ApplicationValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z][a-z0-9]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetSubscriptions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ApplicationValidationError{
						field:  fmt.Sprintf("Subscriptions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ApplicationValidationError{
						field:  fmt.Sprintf("Subscriptions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ApplicationValidationError{
					field:  fmt.Sprintf("Subscriptions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetTargets() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ApplicationValidationError{
						field:  fmt.Sprintf("Targets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ApplicationValidationError{
						field:  fmt.Sprintf("Targets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ApplicationValidationError{
					field:  fmt.Sprintf("Targets[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetIngress() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ApplicationValidationError{
						field:  fmt.Sprintf("Ingress[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ApplicationValidationError{
						field:  fmt.Sprintf("Ingress[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ApplicationValidationError{
					field:  fmt.Sprintf("Ingress[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetBlobstores() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ApplicationValidationError{
						field:  fmt.Sprintf("Blobstores[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ApplicationValidationError{
						field:  fmt.Sprintf("Blobstores[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ApplicationValidationError{
					field:  fmt.Sprintf("Blobstores[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetDatabases() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ApplicationValidationError{
						field:  fmt.Sprintf("Databases[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ApplicationValidationError{
						field:  fmt.Sprintf("Databases[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ApplicationValidationError{
					field:  fmt.Sprintf("Databases[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetRuntimes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ApplicationValidationError{
						field:  fmt.Sprintf("Runtimes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ApplicationValidationError{
						field:  fmt.Sprintf("Runtimes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ApplicationValidationError{
					field:  fmt.Sprintf("Runtimes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ApplicationMultiError(errors)
	}

	return nil
}

// ApplicationMultiError is an error wrapping multiple validation errors
// returned by Application.ValidateAll() if the designated constraints aren't met.
type ApplicationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApplicationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApplicationMultiError) AllErrors() []error { return m }

// ApplicationValidationError is the validation error returned by
// Application.Validate if the designated constraints aren't met.
type ApplicationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplicationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplicationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplicationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplicationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplicationValidationError) ErrorName() string { return "ApplicationValidationError" }

// Error satisfies the builtin error interface
func (e ApplicationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplication.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplicationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplicationValidationError{}

var _Application_Name_Pattern = regexp.MustCompile("^[a-z][a-z0-9]+$")

// Validate checks the field values on Ingress with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Ingress) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Ingress with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in IngressMultiError, or nil if none found.
func (m *Ingress) ValidateAll() error {
	return m.validate(true)
}

func (m *Ingress) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_Ingress_Name_Pattern.MatchString(m.GetName()) {
		err := IngressValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z][a-z0-9]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetHttpRoutes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IngressValidationError{
						field:  fmt.Sprintf("HttpRoutes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IngressValidationError{
						field:  fmt.Sprintf("HttpRoutes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IngressValidationError{
					field:  fmt.Sprintf("HttpRoutes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetGrpcRoutes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IngressValidationError{
						field:  fmt.Sprintf("GrpcRoutes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IngressValidationError{
						field:  fmt.Sprintf("GrpcRoutes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IngressValidationError{
					field:  fmt.Sprintf("GrpcRoutes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return IngressMultiError(errors)
	}

	return nil
}

// IngressMultiError is an error wrapping multiple validation errors returned
// by Ingress.ValidateAll() if the designated constraints aren't met.
type IngressMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IngressMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IngressMultiError) AllErrors() []error { return m }

// IngressValidationError is the validation error returned by Ingress.Validate
// if the designated constraints aren't met.
type IngressValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IngressValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IngressValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IngressValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IngressValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IngressValidationError) ErrorName() string { return "IngressValidationError" }

// Error satisfies the builtin error interface
func (e IngressValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIngress.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IngressValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IngressValidationError{}

var _Ingress_Name_Pattern = regexp.MustCompile("^[a-z][a-z0-9]+$")

// Validate checks the field values on HTTPRoute with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HTTPRoute) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HTTPRoute with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in HTTPRouteMultiError, or nil
// if none found.
func (m *HTTPRoute) ValidateAll() error {
	return m.validate(true)
}

func (m *HTTPRoute) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Prefix

	// no validation rules for TargetRuntime

	if len(errors) > 0 {
		return HTTPRouteMultiError(errors)
	}

	return nil
}

// HTTPRouteMultiError is an error wrapping multiple validation errors returned
// by HTTPRoute.ValidateAll() if the designated constraints aren't met.
type HTTPRouteMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HTTPRouteMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HTTPRouteMultiError) AllErrors() []error { return m }

// HTTPRouteValidationError is the validation error returned by
// HTTPRoute.Validate if the designated constraints aren't met.
type HTTPRouteValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HTTPRouteValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HTTPRouteValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HTTPRouteValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HTTPRouteValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HTTPRouteValidationError) ErrorName() string { return "HTTPRouteValidationError" }

// Error satisfies the builtin error interface
func (e HTTPRouteValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHTTPRoute.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HTTPRouteValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HTTPRouteValidationError{}

// Validate checks the field values on GRPCRoute with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GRPCRoute) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GRPCRoute with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GRPCRouteMultiError, or nil
// if none found.
func (m *GRPCRoute) ValidateAll() error {
	return m.validate(true)
}

func (m *GRPCRoute) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Prefix

	// no validation rules for TargetRuntime

	if len(errors) > 0 {
		return GRPCRouteMultiError(errors)
	}

	return nil
}

// GRPCRouteMultiError is an error wrapping multiple validation errors returned
// by GRPCRoute.ValidateAll() if the designated constraints aren't met.
type GRPCRouteMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GRPCRouteMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GRPCRouteMultiError) AllErrors() []error { return m }

// GRPCRouteValidationError is the validation error returned by
// GRPCRoute.Validate if the designated constraints aren't met.
type GRPCRouteValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GRPCRouteValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GRPCRouteValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GRPCRouteValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GRPCRouteValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GRPCRouteValidationError) ErrorName() string { return "GRPCRouteValidationError" }

// Error satisfies the builtin error interface
func (e GRPCRouteValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGRPCRoute.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GRPCRouteValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GRPCRouteValidationError{}

// Validate checks the field values on Subscription with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Subscription) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Subscription with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SubscriptionMultiError, or
// nil if none found.
func (m *Subscription) ValidateAll() error {
	return m.validate(true)
}

func (m *Subscription) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Topology

	if len(errors) > 0 {
		return SubscriptionMultiError(errors)
	}

	return nil
}

// SubscriptionMultiError is an error wrapping multiple validation errors
// returned by Subscription.ValidateAll() if the designated constraints aren't met.
type SubscriptionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubscriptionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubscriptionMultiError) AllErrors() []error { return m }

// SubscriptionValidationError is the validation error returned by
// Subscription.Validate if the designated constraints aren't met.
type SubscriptionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubscriptionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubscriptionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubscriptionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubscriptionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubscriptionValidationError) ErrorName() string { return "SubscriptionValidationError" }

// Error satisfies the builtin error interface
func (e SubscriptionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubscription.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubscriptionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubscriptionValidationError{}

// Validate checks the field values on Target with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Target) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Target with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TargetMultiError, or nil if none found.
func (m *Target) ValidateAll() error {
	return m.validate(true)
}

func (m *Target) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Topology

	if len(errors) > 0 {
		return TargetMultiError(errors)
	}

	return nil
}

// TargetMultiError is an error wrapping multiple validation errors returned by
// Target.ValidateAll() if the designated constraints aren't met.
type TargetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TargetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TargetMultiError) AllErrors() []error { return m }

// TargetValidationError is the validation error returned by Target.Validate if
// the designated constraints aren't met.
type TargetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TargetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TargetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TargetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TargetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TargetValidationError) ErrorName() string { return "TargetValidationError" }

// Error satisfies the builtin error interface
func (e TargetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTarget.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TargetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TargetValidationError{}

// Validate checks the field values on Blobstore with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Blobstore) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Blobstore with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BlobstoreMultiError, or nil
// if none found.
func (m *Blobstore) ValidateAll() error {
	return m.validate(true)
}

func (m *Blobstore) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if len(errors) > 0 {
		return BlobstoreMultiError(errors)
	}

	return nil
}

// BlobstoreMultiError is an error wrapping multiple validation errors returned
// by Blobstore.ValidateAll() if the designated constraints aren't met.
type BlobstoreMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BlobstoreMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BlobstoreMultiError) AllErrors() []error { return m }

// BlobstoreValidationError is the validation error returned by
// Blobstore.Validate if the designated constraints aren't met.
type BlobstoreValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BlobstoreValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BlobstoreValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BlobstoreValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BlobstoreValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BlobstoreValidationError) ErrorName() string { return "BlobstoreValidationError" }

// Error satisfies the builtin error interface
func (e BlobstoreValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlobstore.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BlobstoreValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BlobstoreValidationError{}

// Validate checks the field values on Database with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Database) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Database with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DatabaseMultiError, or nil
// if none found.
func (m *Database) ValidateAll() error {
	return m.validate(true)
}

func (m *Database) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	switch v := m.Engine.(type) {
	case *Database_Postgres_:
		if v == nil {
			err := DatabaseValidationError{
				field:  "Engine",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPostgres()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DatabaseValidationError{
						field:  "Postgres",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DatabaseValidationError{
						field:  "Postgres",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPostgres()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DatabaseValidationError{
					field:  "Postgres",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return DatabaseMultiError(errors)
	}

	return nil
}

// DatabaseMultiError is an error wrapping multiple validation errors returned
// by Database.ValidateAll() if the designated constraints aren't met.
type DatabaseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DatabaseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DatabaseMultiError) AllErrors() []error { return m }

// DatabaseValidationError is the validation error returned by
// Database.Validate if the designated constraints aren't met.
type DatabaseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DatabaseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DatabaseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DatabaseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DatabaseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DatabaseValidationError) ErrorName() string { return "DatabaseValidationError" }

// Error satisfies the builtin error interface
func (e DatabaseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDatabase.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DatabaseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DatabaseValidationError{}

// Validate checks the field values on Runtime with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Runtime) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Runtime with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in RuntimeMultiError, or nil if none found.
func (m *Runtime) ValidateAll() error {
	return m.validate(true)
}

func (m *Runtime) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_Runtime_Name_Pattern.MatchString(m.GetName()) {
		err := RuntimeValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z][a-z0-9]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetContainers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RuntimeValidationError{
						field:  fmt.Sprintf("Containers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RuntimeValidationError{
						field:  fmt.Sprintf("Containers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RuntimeValidationError{
					field:  fmt.Sprintf("Containers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RuntimeMultiError(errors)
	}

	return nil
}

// RuntimeMultiError is an error wrapping multiple validation errors returned
// by Runtime.ValidateAll() if the designated constraints aren't met.
type RuntimeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RuntimeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RuntimeMultiError) AllErrors() []error { return m }

// RuntimeValidationError is the validation error returned by Runtime.Validate
// if the designated constraints aren't met.
type RuntimeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RuntimeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RuntimeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RuntimeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RuntimeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RuntimeValidationError) ErrorName() string { return "RuntimeValidationError" }

// Error satisfies the builtin error interface
func (e RuntimeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRuntime.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RuntimeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RuntimeValidationError{}

var _Runtime_Name_Pattern = regexp.MustCompile("^[a-z][a-z0-9]+$")

// Validate checks the field values on Container with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Container) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Container with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ContainerMultiError, or nil
// if none found.
func (m *Container) ValidateAll() error {
	return m.validate(true)
}

func (m *Container) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Demand

	for idx, item := range m.GetEnvVars() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ContainerValidationError{
						field:  fmt.Sprintf("EnvVars[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ContainerValidationError{
						field:  fmt.Sprintf("EnvVars[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ContainerValidationError{
					field:  fmt.Sprintf("EnvVars[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	switch v := m.Source.(type) {
	case *Container_ImageUrl:
		if v == nil {
			err := ContainerValidationError{
				field:  "Source",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for ImageUrl
	case *Container_Image_:
		if v == nil {
			err := ContainerValidationError{
				field:  "Source",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetImage()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ContainerValidationError{
						field:  "Image",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ContainerValidationError{
						field:  "Image",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetImage()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ContainerValidationError{
					field:  "Image",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ContainerMultiError(errors)
	}

	return nil
}

// ContainerMultiError is an error wrapping multiple validation errors returned
// by Container.ValidateAll() if the designated constraints aren't met.
type ContainerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ContainerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ContainerMultiError) AllErrors() []error { return m }

// ContainerValidationError is the validation error returned by
// Container.Validate if the designated constraints aren't met.
type ContainerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ContainerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ContainerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ContainerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ContainerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ContainerValidationError) ErrorName() string { return "ContainerValidationError" }

// Error satisfies the builtin error interface
func (e ContainerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sContainer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ContainerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ContainerValidationError{}

// Validate checks the field values on EnvironmentVariable with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EnvironmentVariable) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EnvironmentVariable with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EnvironmentVariableMultiError, or nil if none found.
func (m *EnvironmentVariable) ValidateAll() error {
	return m.validate(true)
}

func (m *EnvironmentVariable) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	switch v := m.Spec.(type) {
	case *EnvironmentVariable_Database:
		if v == nil {
			err := EnvironmentVariableValidationError{
				field:  "Spec",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDatabase()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EnvironmentVariableValidationError{
						field:  "Database",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EnvironmentVariableValidationError{
						field:  "Database",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDatabase()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EnvironmentVariableValidationError{
					field:  "Database",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EnvironmentVariable_Blobstore:
		if v == nil {
			err := EnvironmentVariableValidationError{
				field:  "Spec",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetBlobstore()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EnvironmentVariableValidationError{
						field:  "Blobstore",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EnvironmentVariableValidationError{
						field:  "Blobstore",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetBlobstore()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EnvironmentVariableValidationError{
					field:  "Blobstore",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EnvironmentVariable_EnvMap:
		if v == nil {
			err := EnvironmentVariableValidationError{
				field:  "Spec",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetEnvMap()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EnvironmentVariableValidationError{
						field:  "EnvMap",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EnvironmentVariableValidationError{
						field:  "EnvMap",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEnvMap()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EnvironmentVariableValidationError{
					field:  "EnvMap",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EnvironmentVariable_FromEnv:
		if v == nil {
			err := EnvironmentVariableValidationError{
				field:  "Spec",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetFromEnv()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EnvironmentVariableValidationError{
						field:  "FromEnv",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EnvironmentVariableValidationError{
						field:  "FromEnv",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFromEnv()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EnvironmentVariableValidationError{
					field:  "FromEnv",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return EnvironmentVariableMultiError(errors)
	}

	return nil
}

// EnvironmentVariableMultiError is an error wrapping multiple validation
// errors returned by EnvironmentVariable.ValidateAll() if the designated
// constraints aren't met.
type EnvironmentVariableMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnvironmentVariableMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnvironmentVariableMultiError) AllErrors() []error { return m }

// EnvironmentVariableValidationError is the validation error returned by
// EnvironmentVariable.Validate if the designated constraints aren't met.
type EnvironmentVariableValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnvironmentVariableValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnvironmentVariableValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnvironmentVariableValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnvironmentVariableValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnvironmentVariableValidationError) ErrorName() string {
	return "EnvironmentVariableValidationError"
}

// Error satisfies the builtin error interface
func (e EnvironmentVariableValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnvironmentVariable.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnvironmentVariableValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnvironmentVariableValidationError{}

// Validate checks the field values on DatabaseEnvVar with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DatabaseEnvVar) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DatabaseEnvVar with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DatabaseEnvVarMultiError,
// or nil if none found.
func (m *DatabaseEnvVar) ValidateAll() error {
	return m.validate(true)
}

func (m *DatabaseEnvVar) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DatabaseEnvVarMultiError(errors)
	}

	return nil
}

// DatabaseEnvVarMultiError is an error wrapping multiple validation errors
// returned by DatabaseEnvVar.ValidateAll() if the designated constraints
// aren't met.
type DatabaseEnvVarMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DatabaseEnvVarMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DatabaseEnvVarMultiError) AllErrors() []error { return m }

// DatabaseEnvVarValidationError is the validation error returned by
// DatabaseEnvVar.Validate if the designated constraints aren't met.
type DatabaseEnvVarValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DatabaseEnvVarValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DatabaseEnvVarValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DatabaseEnvVarValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DatabaseEnvVarValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DatabaseEnvVarValidationError) ErrorName() string { return "DatabaseEnvVarValidationError" }

// Error satisfies the builtin error interface
func (e DatabaseEnvVarValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDatabaseEnvVar.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DatabaseEnvVarValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DatabaseEnvVarValidationError{}

// Validate checks the field values on BlobstoreEnvVar with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *BlobstoreEnvVar) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BlobstoreEnvVar with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BlobstoreEnvVarMultiError, or nil if none found.
func (m *BlobstoreEnvVar) ValidateAll() error {
	return m.validate(true)
}

func (m *BlobstoreEnvVar) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return BlobstoreEnvVarMultiError(errors)
	}

	return nil
}

// BlobstoreEnvVarMultiError is an error wrapping multiple validation errors
// returned by BlobstoreEnvVar.ValidateAll() if the designated constraints
// aren't met.
type BlobstoreEnvVarMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BlobstoreEnvVarMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BlobstoreEnvVarMultiError) AllErrors() []error { return m }

// BlobstoreEnvVarValidationError is the validation error returned by
// BlobstoreEnvVar.Validate if the designated constraints aren't met.
type BlobstoreEnvVarValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BlobstoreEnvVarValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BlobstoreEnvVarValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BlobstoreEnvVarValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BlobstoreEnvVarValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BlobstoreEnvVarValidationError) ErrorName() string { return "BlobstoreEnvVarValidationError" }

// Error satisfies the builtin error interface
func (e BlobstoreEnvVarValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlobstoreEnvVar.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BlobstoreEnvVarValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BlobstoreEnvVarValidationError{}

// Validate checks the field values on MapEnvVar with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MapEnvVar) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MapEnvVar with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MapEnvVarMultiError, or nil
// if none found.
func (m *MapEnvVar) ValidateAll() error {
	return m.validate(true)
}

func (m *MapEnvVar) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return MapEnvVarMultiError(errors)
	}

	return nil
}

// MapEnvVarMultiError is an error wrapping multiple validation errors returned
// by MapEnvVar.ValidateAll() if the designated constraints aren't met.
type MapEnvVarMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MapEnvVarMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MapEnvVarMultiError) AllErrors() []error { return m }

// MapEnvVarValidationError is the validation error returned by
// MapEnvVar.Validate if the designated constraints aren't met.
type MapEnvVarValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MapEnvVarValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MapEnvVarValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MapEnvVarValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MapEnvVarValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MapEnvVarValidationError) ErrorName() string { return "MapEnvVarValidationError" }

// Error satisfies the builtin error interface
func (e MapEnvVarValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMapEnvVar.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MapEnvVarValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MapEnvVarValidationError{}

// Validate checks the field values on FromEnvVar with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FromEnvVar) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FromEnvVar with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FromEnvVarMultiError, or
// nil if none found.
func (m *FromEnvVar) ValidateAll() error {
	return m.validate(true)
}

func (m *FromEnvVar) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return FromEnvVarMultiError(errors)
	}

	return nil
}

// FromEnvVarMultiError is an error wrapping multiple validation errors
// returned by FromEnvVar.ValidateAll() if the designated constraints aren't met.
type FromEnvVarMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FromEnvVarMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FromEnvVarMultiError) AllErrors() []error { return m }

// FromEnvVarValidationError is the validation error returned by
// FromEnvVar.Validate if the designated constraints aren't met.
type FromEnvVarValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FromEnvVarValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FromEnvVarValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FromEnvVarValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FromEnvVarValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FromEnvVarValidationError) ErrorName() string { return "FromEnvVarValidationError" }

// Error satisfies the builtin error interface
func (e FromEnvVarValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFromEnvVar.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FromEnvVarValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FromEnvVarValidationError{}

// Validate checks the field values on Database_Postgres with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *Database_Postgres) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Database_Postgres with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Database_PostgresMultiError, or nil if none found.
func (m *Database_Postgres) ValidateAll() error {
	return m.validate(true)
}

func (m *Database_Postgres) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DbName

	// no validation rules for ServerGroup

	if len(errors) > 0 {
		return Database_PostgresMultiError(errors)
	}

	return nil
}

// Database_PostgresMultiError is an error wrapping multiple validation errors
// returned by Database_Postgres.ValidateAll() if the designated constraints
// aren't met.
type Database_PostgresMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Database_PostgresMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Database_PostgresMultiError) AllErrors() []error { return m }

// Database_PostgresValidationError is the validation error returned by
// Database_Postgres.Validate if the designated constraints aren't met.
type Database_PostgresValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Database_PostgresValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Database_PostgresValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Database_PostgresValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Database_PostgresValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Database_PostgresValidationError) ErrorName() string {
	return "Database_PostgresValidationError"
}

// Error satisfies the builtin error interface
func (e Database_PostgresValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDatabase_Postgres.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Database_PostgresValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Database_PostgresValidationError{}

// Validate checks the field values on Container_Image with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *Container_Image) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Container_Image with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Container_ImageMultiError, or nil if none found.
func (m *Container_Image) ValidateAll() error {
	return m.validate(true)
}

func (m *Container_Image) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Tag

	if len(errors) > 0 {
		return Container_ImageMultiError(errors)
	}

	return nil
}

// Container_ImageMultiError is an error wrapping multiple validation errors
// returned by Container_Image.ValidateAll() if the designated constraints
// aren't met.
type Container_ImageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Container_ImageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Container_ImageMultiError) AllErrors() []error { return m }

// Container_ImageValidationError is the validation error returned by
// Container_Image.Validate if the designated constraints aren't met.
type Container_ImageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Container_ImageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Container_ImageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Container_ImageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Container_ImageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Container_ImageValidationError) ErrorName() string { return "Container_ImageValidationError" }

// Error satisfies the builtin error interface
func (e Container_ImageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sContainer_Image.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Container_ImageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Container_ImageValidationError{}
